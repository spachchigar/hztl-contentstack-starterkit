/**
 * Language Fetcher Script
 * 
 * Fetches all available languages/locales from Contentstack and generates
 * a TypeScript constants file for use throughout the application.
 * 
 * This script should be run during the build process to ensure the application
 * always has the latest language configuration from Contentstack.
 * 
 * @usage
 *
 * tsx scripts/fetch-language.ts
 * 
 * @output constants/locales.ts - Generated TypeScript file with locale constants
 * 
 * @requires CONTENTSTACK_MANAGEMENT_TOKEN
 * @requires CONTENTSTACK_API_KEY
 */

import * as fs from 'fs';
import * as path from 'path';
import { fetchLocales, testConnection } from '../lib/contentstack/management-stack';
import { Locale } from '@contentstack/management/types/stack/locale';

/**
 * Configuration for the script
 */
const CONFIG = {
    outputFile: path.join(process.cwd(), 'constants', 'locales.ts'),
} as const;

/**
 * Logger utility for consistent output formatting
 */
const logger = {
    info: (message: string) => console.log(`â„¹ï¸  ${message}`),
    success: (message: string) => console.log(`âœ… ${message}`),
    warn: (message: string) => console.warn(`âš ï¸  ${message}`),
    error: (message: string) => console.error(`âŒ ${message}`),
    debug: (message: string) => console.log(`ðŸ” ${message}`),
};

/**
 * Processes raw locale data from Contentstack into structured format
 * 
 * @param languages - Array of locale objects from Contentstack
 * @returns Processed locale configuration
 */
function processLocales(languages: Locale[]) {
    logger.debug(`Processing ${languages.length} locales`);

    // Extract locale codes
    const locales = languages.map((lang) => lang.code);

    // Determine default locale (one without fallback or first in list)
    const defaultLocale = languages.find(
        (lang) => !lang.fallback_locale || lang.fallback_locale === lang.code
    )?.code || locales[0];

    if (!defaultLocale) {
        throw new Error('Could not determine default locale from stack');
    }

    // Create language details with country code, native name, and ISO code
    const languageDetails = languages.map(
        (lang) => {
            const isoCode = lang.code.split('-')[0];
            const langCode = lang.code;

            // Extract native name from the name field (part before " - ")
            const nativeName = lang.name.split(' - ')[0].trim();
            const countryName = lang.name.includes(' - ')
                ? lang.name.split(' - ')[1].trim()
                : null;

            return {
                countryName,
                nativeName,
                isoCode,
                langCode,
            };
        }).sort((a, b) => a.nativeName.localeCompare(b.nativeName));

    logger.debug(`Default locale: ${defaultLocale}`);

    return {
        locales,
        defaultLocale,
        languageDetails,
    };
}

/**
 * Generates TypeScript file content with locale constants
 * 
 * @param data - Processed locale configuration
 * @returns TypeScript file content as string
 */
function generateTypeScriptContent(data: ReturnType<typeof processLocales>): string {

    return `/**
 * Locale Constants
 * 
 * This file is auto-generated by scripts/fetch-language.ts
 * 
 * @see scripts/fetch-language.ts
 * 
 * DO NOT EDIT MANUALLY - Changes will be overwritten on next build
 */

export interface LanguageDetail {
  countryName: string | null; // Country name (extracted from Contentstack)
  nativeName: string; // Language name in its native script (extracted from Contentstack)
  isoCode: string; // ISO 639-1 language code (e.g., "en", "fr")
  langCode: string; // Language code (e.g., "en", "fr", "en-us", "tr-tr")
}

// Available locales in the Contentstack stack
export const SUPPORTED_LOCALES = ${JSON.stringify(data.locales, null, 2)} as const;

// Default locale for the application
export const DEFAULT_LOCALE = '${data.defaultLocale}' as const;

// TypeScript type for supported locales
export type SupportedLocale = (typeof SUPPORTED_LOCALES)[number];

/**
 * Detailed language information
 * Includes country code, native name, and ISO language code
 */

export const LANGUAGE_DETAILS: LanguageDetail[] = ${JSON.stringify(data.languageDetails, null, 2)};

/**
 * Languages that should not appear in URL paths
 * Typically includes the default language to keep URLs clean
 */
export const LANGUAGES_WITHOUT_URL_PREFIX = [DEFAULT_LOCALE as string];
`;
}

/**
 * Writes the generated content to the output file
 * 
 * @param content - TypeScript file content to write
 */
function writeOutputFile(content: string): void {
    const outputDir = path.dirname(CONFIG.outputFile);

    // Ensure output directory exists
    if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
        logger.info(`Created directory: ${outputDir}`);
    }

    // Write the generated file
    fs.writeFileSync(CONFIG.outputFile, content, 'utf-8');

    logger.success(`Generated: ${CONFIG.outputFile}`);
}

/**
 * Main execution function
 * Orchestrates the entire language fetching and generation process
 */
async function main(): Promise<void> {
    logger.info('Starting language fetch from Contentstack...');

    try {
        // Step 1: Test connection
        logger.info('Testing Contentstack Management API connection...');
        await testConnection();
        logger.success('Connection successful');

        // Step 2: Fetch locales
        logger.info('Fetching locales from stack...');
        const languages = await fetchLocales();

        if (languages.length === 0) {
            throw new Error('No locales found in Contentstack stack');
        }

        logger.success(`Found ${languages.length} locale${languages.length > 1 ? 's' : ''}`);
        languages.forEach((lang) => {
            logger.info(`  - ${lang.code} (${lang.name})`);
        });

        // Step 3: Process locale data
        logger.info('Processing locale data...');
        const processedData = processLocales(languages);

        // Step 4: Generate TypeScript content
        logger.info('Generating TypeScript file...');
        const fileContent = generateTypeScriptContent(processedData);

        // Step 6: Write output file
        writeOutputFile(fileContent);

        // Summary
        logger.success('Language fetch complete!');
        logger.info(`  Locales: ${processedData.locales.join(', ')}`);
        logger.info(`  Default: ${processedData.defaultLocale}`);
        logger.info(`  Output: ${CONFIG.outputFile}`);

    } catch (error) {
        logger.error('Language fetch failed');

        if (error instanceof Error) {
            logger.error(error.message);

            // Provide helpful error messages
            if (error.message.includes('CONTENTSTACK_MANAGEMENT_TOKEN')) {
                logger.info('Hint: Make sure your .env file contains CONTENTSTACK_MANAGEMENT_TOKEN');
                logger.info('      You can generate one at: Settings â†’ Tokens â†’ Management Tokens');
            } else if (error.message.includes('CONTENTSTACK_API_KEY')) {
                logger.info('Hint: Make sure your .env file contains CONTENTSTACK_API_KEY');
            } else if (error.message.includes('authentication')) {
                logger.info('Hint: Check that your CONTENTSTACK_MANAGEMENT_TOKEN is valid and has appropriate permissions');
            }
        }

        // Exit with error code
        process.exit(1);
    }
}

// Execute the script
main()
    .then(() => {
        process.exit(0);
    })
    .catch((error) => {
        logger.error(`Unexpected error: ${error instanceof Error ? error.message : 'Unknown error'}`);
        process.exit(1);
    });