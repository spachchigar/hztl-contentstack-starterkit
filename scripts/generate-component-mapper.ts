import fs from 'fs';
import path from 'path';
import chokidar from 'chokidar';

// ============================================================================
// CONFIGURATION: Add your component directories here (scans recursively)
// ============================================================================
const ALLOWED_COMPONENT_PATHS = [
  'components/authorable/shared',
  'components/ui',
  // Add more paths here as needed
  // Example: 'components/shared',
  // Example: 'components/features',
];

// Convert relative paths to absolute paths
const registeredComponentsDirs = ALLOWED_COMPONENT_PATHS.map((dir) =>
  path.join(__dirname, '..', dir)
);


// Path to the config directory where we'll create the barrel file
const configDir = path.join(__dirname, '..', 'temp');

// Helper to get relative import path from configDir to component file
const getRelativeImportPath = (componentFilePath: string) => {
  return path.relative(configDir, componentFilePath).replace(/\\/g, '/');
};

/**
 * Recursively find all component files in a directory
 * @param dirPath - Directory path to scan
 * @param componentFiles - Array to collect found files
 */
const findComponentFiles = (dirPath: string, componentFiles: Array<{ file: string; dir: string }> = []): Array<{ file: string; dir: string }> => {
  if (!fs.existsSync(dirPath)) {
    return componentFiles;
  }

  const entries = fs.readdirSync(dirPath, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dirPath, entry.name);
    // Using statSync for more reliable file type detection
    const stats = fs.statSync(fullPath);

    // Skip node_modules, .git, and other hidden directories
    if (stats.isDirectory() && !entry.name.startsWith('.') && entry.name !== 'node_modules') {
      // Recursively scan subdirectories
      findComponentFiles(fullPath, componentFiles);
    } else if (entry.isFile()) {
      // Check if it's a component file
      if (
        entry.name.endsWith('.tsx') ||
        entry.name.endsWith('.jsx') ||
        entry.name.endsWith('.ts') ||
        entry.name.endsWith('.js')
      ) {
        componentFiles.push({
          file: entry.name,
          dir: dirPath,
        });
      }
    }
  }

  return componentFiles;
};

// Function to get all component files from the directories
export const generateRegisteredComponents = () => {
  try {
    // Ensure config directory exists
    if (!fs.existsSync(configDir)) {
      fs.mkdirSync(configDir, { recursive: true });
    }

    // Collect all component files from all directories (recursively)
    const componentMap = new Map<string, { file: string; dir: string }>();

    for (const dir of registeredComponentsDirs) {
      const files = findComponentFiles(dir);

      files.forEach(({ file, dir: fileDir }) => {
        const componentName = path.basename(file, path.extname(file));
        // Only add if not already present (first occurrence wins)
        if (!componentMap.has(componentName)) {
          componentMap.set(componentName, {
            file,
            dir: fileDir,
          });
        }
      });
    }

    // Generate import statements
    const imports = Array.from(componentMap.entries())
      .map(([componentName, { file, dir }]) => {
        const absPath = path.join(dir, file);
        const relImportPath = getRelativeImportPath(absPath).replace(/\.(tsx|jsx|js|ts)$/, '');
        return `import { ${componentName} } from '${relImportPath}';`;
      })
      .join('\n');

    // Import the ComponentMapper class
    const mapperImport = "import { componentMapperInstance } from '../utils/ComponentMapper';";

    const exportComponentTypes = `export type ComponentTypes = ${Array.from(componentMap.keys())
      .map((componentName) => `'${componentName}'`)
      .join(' | ')};`;

    // Generate component registration statements
    const componentRegistrations = Array.from(componentMap.keys())
      .map((componentName) => {
        return `componentMapperInstance.register('${componentName}', ${componentName});`;
      })
      .join('\n');

    // Generate export statements for a barrel file
    const exports = Array.from(componentMap.keys())
      .map((componentName) => {
        return `  ${componentName},`;
      })
      .join('\n');

    // Create a barrel file content with component map
    const barrelFileContent = `// Do not edit this file as it is an auto generated file
// If you need to update this file, please look into "/scripts/generate-component-mapper.ts"

${imports}
${mapperImport}

// Component names as a type
${exportComponentTypes}

// Register all components with the ComponentMapper
${componentRegistrations}

// Export the componentMapperInstance for use in the application
export const componentMapper = componentMapperInstance;

// Export all components individually
export {
${exports}
};
`;

    // Write the barrel file to the config directory
    fs.writeFileSync(path.join(configDir, 'registered-components.ts'), barrelFileContent);

    return Array.from(componentMap.keys());
  } catch (error) {
    console.error('Error reading registered components directories:', error);
    return [];
  }
};

// Watch mode functionality
const startWatchMode = () => {
  // Initialize watcher for all directories (recursive watching)
  const watcher = chokidar.watch(registeredComponentsDirs, {
    ignored: /(^|[/\\])(\.|node_modules)/, // ignore dotfiles and node_modules
    persistent: true,
    ignoreInitial: false, // Run immediately on startup
    depth: 99, // Watch recursively to any depth
  });

  let isGenerating = false;

  // Debounce function to avoid running multiple times in quick succession
  const debounce = (func: () => void, wait: number) => {
    let timeout: NodeJS.Timeout;
    return function executedFunction() {
      const later = () => {
        clearTimeout(timeout);
        func();
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  };

  // Debounced version of the generator
  const debouncedGenerate = debounce(() => {
    if (isGenerating) return;

    isGenerating = true;

    try {
      generateRegisteredComponents();
    } catch (error) {
      console.error('❌ Error updating component mapper:', error);
    } finally {
      isGenerating = false;
    }
  }, 100);

  // File system event handlers
  watcher
    .on('add', (filePath) => {
      const fileName = path.basename(filePath);
      if (fileName.match(/\.(tsx?|jsx?)$/)) {
        debouncedGenerate();
      }
    })
    .on('unlink', (filePath) => {
      const fileName = path.basename(filePath);
      if (fileName.match(/\.(tsx?|jsx?)$/)) {
        debouncedGenerate();
      }
    })
    .on('ready', () => { })
    .on('error', (error) => {
      console.error('❌ Watcher error:', error);
    });

  // Graceful shutdown
  process.on('SIGINT', () => {
    watcher.close().then(() => {
      process.exit(0);
    });
  });

  process.on('SIGTERM', () => {
    watcher.close().then(() => {
      process.exit(0);
    });
  });
};

// Main execution logic
const main = () => {
  const args = process.argv.slice(2);
  const isWatchMode = args.includes('--watch') || args.includes('-w');

  if (isWatchMode) {
    startWatchMode();
  } else {
    // Run once and exit
    generateRegisteredComponents();
  }
};

// Run the script if called directly
if (require.main === module) {
  main();
}