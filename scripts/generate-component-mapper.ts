import fs from 'fs';
import path from 'path';
import chokidar from 'chokidar';

// List of registered component directories (add more as needed)
const registeredComponentsDirs = [
  path.join(__dirname, '..', 'components', 'authorable'),
  ...fs
    .readdirSync(path.join(__dirname, '..', 'components', 'authorable'), { withFileTypes: true })
    .filter((dirent) => dirent.isDirectory())
    .map((dirent) => path.join(__dirname, '..', 'components', 'authorable', dirent.name)),
  path.join(__dirname, '..', 'components', 'ui'),
  ...fs
    .readdirSync(path.join(__dirname, '..', 'components', 'ui'), { withFileTypes: true })
    .filter((dirent) => dirent.isDirectory())
    .map((dirent) => path.join(__dirname, '..', 'components', 'ui', dirent.name)),
  // Add more directories here if needed
];
// Path to the config directory where we'll create the barrel file
const configDir = path.join(__dirname, '..', 'temp');

// Helper to get relative import path from configDir to component file
const getRelativeImportPath = (componentFilePath: string) => {
  return path.relative(configDir, componentFilePath).replace(/\\/g, '/');
};

// Function to get all component files from the directories
export const generateRegisteredComponents = () => {
  try {
    // Ensure config directory exists
    if (!fs.existsSync(configDir)) {
      fs.mkdirSync(configDir, { recursive: true });
    }

    // Collect all component files from all directories
    const componentMap = new Map(); // Map<componentName, { file, dir }>
    for (const dir of registeredComponentsDirs) {
      if (!fs.existsSync(dir)) continue;
      const files = fs.readdirSync(dir);
      files.forEach((file) => {
        if (
          file.endsWith('.tsx') ||
          file.endsWith('.jsx') ||
          file.endsWith('.js') ||
          file.endsWith('.ts')
        ) {
          const componentName = path.basename(file, path.extname(file));
          // Only add if not already present (first occurrence wins)
          if (!componentMap.has(componentName)) {
            componentMap.set(componentName, {
              file,
              dir,
            });
          }
        }
      });
    }

    // Generate import statements
    const imports = Array.from(componentMap.entries())
      .map(([componentName, { file, dir }]) => {
        const absPath = path.join(dir, file);
        const relImportPath = getRelativeImportPath(absPath).replace(/\.(tsx|jsx|js|ts)$/, '');
        return `import { ${componentName} } from '${relImportPath}';`;
      })
      .join('\n');

    // Import the ComponentMapper class
    const mapperImport = "import { componentMapperInstance } from '../utils/ComponentMapper';";

    const exportComponentTypes = `export type ComponentTypes = ${Array.from(componentMap.keys())
      .map((componentName) => `'${componentName}'`)
      .join(' | ')};`;

    // Generate component registration statements
    const componentRegistrations = Array.from(componentMap.keys())
      .map((componentName) => {
        return `componentMapperInstance.register('${componentName}', ${componentName});`;
      })
      .join('\n');

    // Generate export statements for a barrel file
    const exports = Array.from(componentMap.keys())
      .map((componentName) => {
        return `  ${componentName},`;
      })
      .join('\n');

    // Create a barrel file content with component map
    const barrelFileContent = `// Do not edit this file as it is an auto generated file
// If you need to update this file, please look into "/scripts/generate-component-mapper.ts"

${imports}
${mapperImport}

// Component names as a type
${exportComponentTypes}

// Register all components with the ComponentMapper
${componentRegistrations}

// Export the componentMapperInstance for use in the application
export const componentMapper = componentMapperInstance;

// Export all components individually
export {
${exports}
};
`;

    // Write the barrel file to the config directory
    fs.writeFileSync(path.join(configDir, 'registered-components.ts'), barrelFileContent);

    return Array.from(componentMap.keys());
  } catch (error) {
    console.error('Error reading registered components directories:', error);
    return [];
  }
};

// Watch mode functionality
const startWatchMode = () => {
  // Initialize watcher for all directories
  const watcher = chokidar.watch(registeredComponentsDirs, {
    ignored: /(^|[/\\])\../, // ignore dotfiles
    persistent: true,
    ignoreInitial: false, // Run immediately on startup
  });

  let isGenerating = false;

  // Debounce function to avoid running multiple times in quick succession
  const debounce = (func: () => void, wait: number) => {
    let timeout: NodeJS.Timeout;
    return function executedFunction() {
      const later = () => {
        clearTimeout(timeout);
        func();
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  };

  // Debounced version of the generator
  const debouncedGenerate = debounce(() => {
    if (isGenerating) return;

    isGenerating = true;

    try {
      generateRegisteredComponents();
    } catch (error) {
      console.error('❌ Error updating component mapper:', error);
    } finally {
      isGenerating = false;
    }
  }, 100);

  // File system event handlers
  watcher
    .on('add', (filePath) => {
      const fileName = path.basename(filePath);
      if (fileName.match(/\.(tsx?|jsx?)$/)) {
        debouncedGenerate();
      }
    })
    .on('unlink', (filePath) => {
      const fileName = path.basename(filePath);
      if (fileName.match(/\.(tsx?|jsx?)$/)) {
        debouncedGenerate();
      }
    })
    .on('ready', () => {})
    .on('error', (error) => {
      console.error('❌ Watcher error:', error);
    });

  // Graceful shutdown
  process.on('SIGINT', () => {
    watcher.close().then(() => {
      process.exit(0);
    });
  });

  process.on('SIGTERM', () => {
    watcher.close().then(() => {
      process.exit(0);
    });
  });
};

// Main execution logic
const main = () => {
  const args = process.argv.slice(2);
  const isWatchMode = args.includes('--watch') || args.includes('-w');

  if (isWatchMode) {
    startWatchMode();
  } else {
    // Run once and exit
    generateRegisteredComponents();
  }
};

// Run the script if called directly
if (require.main === module) {
  main();
}
