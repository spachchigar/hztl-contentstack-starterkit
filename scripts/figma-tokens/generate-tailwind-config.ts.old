/* eslint-disable @typescript-eslint/no-explicit-any */
/*
 * Import dependencies
 */
import fs from 'fs';
import path from 'path';

/*
 * Defining a Path that contain JSON files generated in step 1
 */
const figmaTokensPath = './tokens';
const directoryPath = path.resolve(__dirname, figmaTokensPath);

/*
 * Function to update variable names by removing dots and spaces
 */
function sanitizeTokenName(variableName: string) {
  // Replace dots, spaces, and dashes first (existing functionality)
  let sanitized = variableName.replace(/[.\s-]/g, '');

  // Replace % with - and remove parentheses
  sanitized = sanitized.replace(/%/g, '-').replace(/[()]/g, '');

  return sanitized;
}

/*
 * Recursive function to transform nested objects
 * If the item is an object, recursively process it
 * If it contains $value and $type, process the item
 * Check if $extentions.com.figma.codeSyntax.WEB is defined
 * Sanitize key name, and only add the parent prefix if codeSyntaxWeb exists
 */
function filterDataObjects(
  groupName: string,
  obj: { [x: string]: any; hasOwnProperty: (arg0: string) => any }
) {
  const result: { [key: string]: any } = {};
  const colorResults: { [key: string]: any } = {};
  const spacingResults: { [key: string]: any } = {};
  const borderRadiusResults: { [key: string]: any } = {};
  const borderWidthResults: { [key: string]: any } = {};
  const widthResults: { [key: string]: any } = {};
  const heightResults: { [key: string]: any } = {};
  const minWidthResults: { [key: string]: any } = {};
  const maxWidthResults: { [key: string]: any } = {};
  const minHeightResults: { [key: string]: any } = {};
  const maxHeightResults: { [key: string]: any } = {};
  const fontSizeResults: { [key: string]: any } = {};
  const fontFamilyResults: { [key: string]: any } = {};
  const fontWeightResults: { [key: string]: any } = {};
  const letterSpacingResults: { [key: string]: any } = {};

  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      const item = obj[key];
      if (typeof item === 'object' && item !== null) {
        if ('$value' in item && '$type' in item) {
          let value = item['$value'];
          const type = item['$type'];
          const extensionScope = item?.$extensions?.['com.figma']?.scopes;
          const isOpacity = extensionScope?.includes('OPACITY');

          // Update the groupName to replace spaces with '-'
          if (/\s/.test(groupName)) {
            groupName = groupName.replace(/\s+/g, '-');
          }

          // Construct and sanitize the key
          let newKey = `${groupName}-${key}`;

          // Replace spaces first as in existing code
          if (/\s/.test(newKey)) {
            newKey = newKey.replace(/\s+/g, '');
          }

          // Now sanitize % and ()
          newKey = newKey.replace(/%/g, '-').replace(/[()]/g, '');

          // Now lowercase all letters
          newKey = newKey.toLowerCase();

          // Add checks for screen dimensions and min/max values
          const isScreenDimension = newKey.match(/screen-dimensions/i);
          const isWidthValue = newKey.match(/width/i);
          const isHeightValue = newKey.match(/height/i);
          const isMinMaxValue = groupName.toLowerCase().includes('min-max');
          const isStandardValue = groupName.toLowerCase().includes('standard');

          // Improved check for different value types
          const isColorValue =
            type === 'color' ||
            (typeof value === 'string' && /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(value)) ||
            key.includes('color') ||
            (key.includes('border') && !key.includes('radius')) ||
            newKey.includes('color') ||
            (newKey.includes('border') && !newKey.includes('radius'));

          const isSpacingValue =
            newKey.match(/(spacing|padding|margin|space-between|layout)/i) &&
            !newKey.match(/letter-spacing/i);
          const isRadiusValue = newKey.match(/radius/i);
          const isBorderWidthValue = newKey.includes('border-width');
          const isFontSizeValue = newKey.match(/font-size/i);
          const isFontFamilyValue = newKey.match(/font-family/i);
          const isFontWeightValue = newKey.match(/font-weight/i);
          const isLetterSpacingValue = newKey.match(/letter-spacing/i);

          if (value && typeof value === 'string' && value.startsWith('{') && value.endsWith('}')) {
            value = value.replace(/[.\s]/g, '-');
          } else if (
            (type === 'number' && value !== 0 && isOpacity) ||
            (type === 'number' && value !== 0 && key.startsWith('opacity'))
          ) {
            value = value / 100;
          } else if (type === 'number' && value !== 0 && !isOpacity) {
            const baseFontSize = 16;
            value = `${value / baseFontSize}rem`;
          } else if (type === 'boolean') {
            value = `${value}`;
          }

          // Map font weights to numeric values
          if (isFontWeightValue) {
            if (typeof value === 'string') {
              value = value.toLowerCase();
              switch (value) {
                case 'medium':
                  value = '500';
                  break;
                case 'bold':
                  value = '700';
                  break;
                case 'semi bold':
                  value = '600';
                  break;
                case 'regular':
                  value = '400';
                  break;
                case 'light':
                  value = '300';
                  break;
              }
            }
          }

          if (/[A-Z]/.test(value)) {
            value = value.toLowerCase();
          }

          // Handle width/height categorization
          if (isWidthValue) {
            if (isMinMaxValue) {
              if (key.toLowerCase().includes('minwidth')) {
                minWidthResults[newKey] = value;
              } else if (key.toLowerCase().includes('maxwidth')) {
                maxWidthResults[newKey] = value;
              }
            } else if (isStandardValue || isScreenDimension) {
              widthResults[newKey] = value;
            } else if (isBorderWidthValue) {
              const fullKey = newKey;
              borderWidthResults[fullKey] = value;
            }
          } else if (isHeightValue) {
            if (isMinMaxValue) {
              if (key.toLowerCase().includes('minheight')) {
                minHeightResults[newKey] = value;
              } else if (key.toLowerCase().includes('maxheight')) {
                maxHeightResults[newKey] = value;
              }
            } else if (isStandardValue || isScreenDimension) {
              heightResults[newKey] = value;
            }
          } else if (isColorValue) {
            colorResults[newKey] = value;
          } else if (groupName.includes('space between')) {
            spacingResults[newKey] = value;
          } else if (isSpacingValue) {
            spacingResults[newKey] = value;
          } else if (isLetterSpacingValue) {
            letterSpacingResults[newKey] = value;
          } else if (isColorValue) {
            colorResults[newKey] = value;
          } else if (isWidthValue) {
            widthResults[newKey] = value;
          } else if (isHeightValue) {
            heightResults[newKey] = value;
          } else if (isRadiusValue) {
            const fullKey = newKey;
            borderRadiusResults[fullKey] = value;
          } else if (isBorderWidthValue) {
            const fullKey = newKey;
            borderWidthResults[fullKey] = value;
          } else if (isFontSizeValue) {
            fontSizeResults[newKey] = value;
          } else if (isFontFamilyValue) {
            fontFamilyResults[newKey] = `var(--font-${value})`;
          } else if (isFontWeightValue) {
            fontWeightResults[newKey] = value;
          } else {
            result[newKey] = value;
          }
        } else if (typeof item === 'object' && item !== null) {
          const hasNestedObjects = Object.values(item).some(
            (subItem) => typeof subItem === 'object' && subItem !== null
          );

          if (!hasNestedObjects) {
            const nestedResults = filterDataObjects(`${groupName}-${key}`, item);
            Object.assign(result, nestedResults.result);
            Object.assign(colorResults, nestedResults.colors);
            Object.assign(spacingResults, nestedResults.spacing);
            Object.assign(borderRadiusResults, nestedResults.borderRadius);
            Object.assign(borderWidthResults, nestedResults.borderWidth);
            Object.assign(widthResults, nestedResults.width);
            Object.assign(heightResults, nestedResults.height);
            Object.assign(minWidthResults, nestedResults.minWidth);
            Object.assign(maxWidthResults, nestedResults.maxWidth);
            Object.assign(minHeightResults, nestedResults.minHeight);
            Object.assign(maxHeightResults, nestedResults.maxHeight);
            Object.assign(fontSizeResults, nestedResults.fontSize);
            Object.assign(fontFamilyResults, nestedResults.fontFamily);
            Object.assign(fontWeightResults, nestedResults.fontWeight);
            Object.assign(letterSpacingResults, nestedResults.letterSpacing);
          } else {
            const nestedResults = filterDataObjects(`${groupName}-${key}`, item);
            Object.assign(result, nestedResults.result);
            Object.assign(colorResults, nestedResults.colors);
            Object.assign(spacingResults, nestedResults.spacing);
            Object.assign(borderRadiusResults, nestedResults.borderRadius);
            Object.assign(borderWidthResults, nestedResults.borderWidth);
            Object.assign(widthResults, nestedResults.width);
            Object.assign(heightResults, nestedResults.height);
            Object.assign(minWidthResults, nestedResults.minWidth);
            Object.assign(maxWidthResults, nestedResults.maxWidth);
            Object.assign(minHeightResults, nestedResults.minHeight);
            Object.assign(maxHeightResults, nestedResults.maxHeight);
            Object.assign(fontSizeResults, nestedResults.fontSize);
            Object.assign(fontFamilyResults, nestedResults.fontFamily);
            Object.assign(fontWeightResults, nestedResults.fontWeight);
            Object.assign(letterSpacingResults, nestedResults.letterSpacing);
          }

          // For 'space between' items, add them to spacing
          if (key === 'space between') {
            const spaceResults = filterDataObjects(`${groupName}-${key}`, item);
            Object.assign(spacingResults, spaceResults.spacing);
          }
        }
      }
    }
  }

  return {
    result,
    colors: colorResults,
    spacing: spacingResults,
    borderRadius: borderRadiusResults,
    borderWidth: borderWidthResults,
    width: widthResults,
    height: heightResults,
    minWidth: minWidthResults,
    maxWidth: maxWidthResults,
    minHeight: minHeightResults,
    maxHeight: maxHeightResults,
    fontSize: fontSizeResults,
    fontFamily: fontFamilyResults,
    fontWeight: fontWeightResults,
    letterSpacing: letterSpacingResults,
  };
}

/*
 * Helper function to resolve a variable
 * Traverse the DefaultVariables to find the value
 * findInNestedObject(variables, varKey);
 */
function replacePlaceholders(obj: any, variables: any, applyDynamicVariables: boolean) {
  const resolveVariable = (value: string) => {
    const match = value.match(/{([^}]+)}/);
    if (match) {
      const varKey = match[1];
      console.info(`Resolving variable: \x1b[35m${varKey}\x1b[0m`);
      const resolvedValue = findInNestedObject(variables, varKey.toLowerCase());
      if (resolvedValue !== undefined) {
        console.info(`Resolved: \x1b[32m$${varKey}\x1b[0m => \x1b[32m$${resolvedValue}\x1b[0m`);
        return resolvedValue;
      } else {
        // console.warn('\x1b[33m%s\x1b[0m', `Warning: Could not resolve variable ${varKey}`);
        // return value;
        if (!applyDynamicVariables) {
          console.warn('\x1b[33m%s\x1b[0m', `Warning: Could not resolve variable ${varKey}`);
          return value;
        } else {
          console.info(
            `Resolved with a CSS variable: \x1b[32m$${varKey}\x1b[0m => \x1b[32m$${resolvedValue}\x1b[0m`
          );
          if (varKey.startsWith('color')) {
            return `rgb(var(--colors-${varKey}) / 1)`;
          } else if (varKey.startsWith('spacing')) {
            return `var(--spacing-${varKey})`;
          } else if (varKey.startsWith('general')) {
            return `rgb(var(--colors-${varKey}) / 1)`;
          } else if (varKey.startsWith('component')) {
            return `rgb(var(--component-${varKey}) / 1)`;
          } else if (varKey.startsWith('typography-')) {
            return `var(--fontSize-${varKey})`;
          }
          // return `rgb(var(--${varKey}) / 1)`;
          return `var(--${varKey})`;
          // return value;
        }
      }
    }

    return value;
  };

  /*
   * Helper function to find the variable in the nested structure
   * Perform a case-insensitive comparison
   * Recursive function to traverse and update the object
   * Add a comment showing the replacement
   */
  const findInNestedObject = (obj: { [x: string]: { [x: string]: any } }, key: string) => {
    for (const category in obj) {
      if (obj[category] && typeof obj[category] === 'object') {
        for (const innerKey in obj[category]) {
          if (innerKey.toLowerCase() === key) {
            return obj[category][innerKey];
          }
        }
      }
    }
    return undefined;
  };

  const traverseAndReplace = (currentObj: { [x: string]: any }) => {
    for (const key in currentObj) {
      if (typeof currentObj[key] === 'string') {
        const originalValue = currentObj[key];
        const newValue = resolveVariable(originalValue);
        currentObj[key] = newValue;

        if (originalValue !== newValue) {
          console.info(
            `Replaced in \x1b[32m${key}\x1b[0m: \x1b[32m${originalValue}\x1b[0m -> \x1b[32m${newValue}\x1b[0m`
          );
        }
      } else if (typeof currentObj[key] === 'object' && currentObj[key] !== null) {
        traverseAndReplace(currentObj[key]);
      }
    }
  };

  traverseAndReplace(obj);
}

/*
 * Function to prefix keys with "custom-" for all nested keys in an object
 * Function to prefix nested keys with "custom-" in an object
 * Only prefix nested keys; skip top-level keys
 * Recurse into the nested object
 * Prefix only the nested keys
 */
const prefixDeviceVariables = (obj: { [x: string]: any }, prefix: string) => {
  for (const key in obj) {
    if (typeof obj[key] === 'object' && obj[key] !== null) {
      prefixDeviceVariables(obj[key], `${prefix}-`);
    } else {
      const newKey = `${prefix}${key}`;
      obj[newKey] = obj[key];
      delete obj[key];
    }
  }
};

/*
 * Updating the jsonFiles that already contains DefaultVariables
 * Replace the values that refer to another variables with values from Global Default
 * Replace variable placeholders with value reference
 * replacePlaceholders(jsonFiles[key], globalDefault);
 * Replace the values that refer to another variables inside of the same theme
 * Replace variable placeholders with value reference
 * Verify one more time if there are remaining {values} that point to another variables after Desktop, Tablet, and Mobile overrides.
 * Add desktop, tablet, mobile prefix in front of Device variables
 */
async function createThemeConfig() {
  try {
    const fileNames = await fs.promises.readdir(directoryPath);
    const jsonFiles: { [key: string]: any } = {};
    const locationColors: { [key: string]: string } = {};

    // First pass: collect all location colors
    for (const fileName of fileNames) {
      if (path.extname(fileName) === '.json' && fileName.startsWith('Location')) {
        const filePath = path.join(directoryPath, fileName);
        // eslint-disable-next-line @typescript-eslint/no-require-imports
        const data = require(filePath);
        const locationName = path.basename(fileName, '.json').replace('Location', '').toLowerCase();

        if (data['brand-location-primary'] && data['brand-location-primary']['$value']) {
          const colorValue = data['brand-location-primary']['$value'];
          locationColors[`brand-location-primary-${locationName}`] = colorValue;
        }
      }
    }

    // Regular processing of all files
    fileNames.forEach((fileName) => {
      if (path.extname(fileName) === '.json') {
        const filePath = path.join(directoryPath, fileName);
        // eslint-disable-next-line @typescript-eslint/no-require-imports
        const data = require(filePath);
        let variableName = path.basename(fileName, '.json');
        variableName = sanitizeTokenName(variableName);

        const transformedData: { [key: string]: any } = {};

        Object.keys(data).forEach((groupName) => {
          const groupData = data[groupName];
          const {
            result,
            colors,
            spacing,
            borderRadius,
            borderWidth,
            width,
            height,
            minWidth,
            maxWidth,
            minHeight,
            maxHeight,
            fontSize,
            fontFamily,
            fontWeight,
            letterSpacing,
          } = filterDataObjects(groupName, groupData);

          // Remove items that have been moved to dedicated sections
          Object.keys(result).forEach((key) => {
            if (
              /(spacing|padding|margin|radius|border-width|font-size|font-family|font-weight|color|letter-spacing|width|height)/i.test(
                key
              )
            ) {
              delete result[key];
            }
          });

          transformedData[groupName] = { ...result };
          transformedData.colors = { ...(transformedData.colors || {}), ...colors };
          transformedData.spacing = { ...(transformedData.spacing || {}), ...spacing };
          transformedData.borderRadius = {
            ...(transformedData.borderRadius || {}),
            ...borderRadius,
          };
          transformedData.borderWidth = {
            ...(transformedData.borderWidth || {}),
            ...borderWidth,
          };
          transformedData.width = { ...(transformedData.width || {}), ...width };
          transformedData.height = { ...(transformedData.height || {}), ...height };
          transformedData.minWidth = { ...(transformedData.minWidth || {}), ...minWidth };
          transformedData.maxWidth = { ...(transformedData.maxWidth || {}), ...maxWidth };
          transformedData.minHeight = { ...(transformedData.minHeight || {}), ...minHeight };
          transformedData.maxHeight = { ...(transformedData.maxHeight || {}), ...maxHeight };
          transformedData.fontSize = { ...(transformedData.fontSize || {}), ...fontSize };
          transformedData.fontFamily = { ...(transformedData.fontFamily || {}), ...fontFamily };
          transformedData.fontWeight = { ...(transformedData.fontWeight || {}), ...fontWeight };
          transformedData.letterSpacing = {
            ...(transformedData.letterSpacing || {}),
            ...letterSpacing,
          };
        });

        jsonFiles[variableName] = transformedData;
      }
    });

    // BrandsBrandX
    if (jsonFiles['BrandsBrandX'] && Object.keys(locationColors).length > 0) {
      if (!jsonFiles['BrandsBrandX'].colors) {
        jsonFiles['BrandsBrandX'].colors = {};
      }

      // Add all location colors to BrandsBrandX colors
      Object.entries(locationColors).forEach(([key, value]) => {
        jsonFiles['BrandsBrandX'].colors[key] = value;
      });
    }

    // BrandsHelloWorld
    if (jsonFiles['BrandsHelloWorld'] && Object.keys(locationColors).length > 0) {
      if (!jsonFiles['BrandsHelloWorld'].colors) {
        jsonFiles['BrandsHelloWorld'].colors = {};
      }

      // Add all location colors to BrandsHelloWorld colors
      Object.entries(locationColors).forEach(([key, value]) => {
        jsonFiles['BrandsHelloWorld'].colors[key] = value;
      });
    }

    // BrandsNimbusGoods
    if (jsonFiles['BrandsNimbusGoods'] && Object.keys(locationColors).length > 0) {
      if (!jsonFiles['BrandsNimbusGoods'].colors) {
        jsonFiles['BrandsNimbusGoods'].colors = {};
      }

      // Add all location colors to BrandsNimbusGoods colors
      Object.entries(locationColors).forEach(([key, value]) => {
        jsonFiles['BrandsNimbusGoods'].colors[key] = value;
      });
    }

    const BrandsBrandX = jsonFiles['BrandsBrandX']; // BrandsBrandX Brand
    const BrandsHelloWorld = jsonFiles['BrandsHelloWorld']; // BrandsHelloWorld Brand
    const BrandsNimbusGoods = jsonFiles['BrandsNimbusGoods']; // BrandsNimbusGoods Brand
    const globalDefault = jsonFiles['GlobalMode1']; // Global Default
    const deviceDesktop = jsonFiles['DeviceDesktop']; // Device Desktop
    const deviceTablet = jsonFiles['DeviceTablet']; // Device Tablet
    const deviceMobile = jsonFiles['DeviceMobile']; // Device Mobile

    Object.keys(jsonFiles).forEach((key) => {
      if (key === 'BrandsBrandX') {
        replacePlaceholders(jsonFiles[key], BrandsBrandX, false);
      }
      if (key === 'BrandsHelloWorld') {
        replacePlaceholders(jsonFiles[key], BrandsHelloWorld, false);
      }
      if (key === 'BrandsNimbusGoods') {
        replacePlaceholders(jsonFiles[key], BrandsNimbusGoods, false);
      }

      replacePlaceholders(jsonFiles[key], globalDefault, false);
      replacePlaceholders(jsonFiles[key], deviceDesktop, false);
      replacePlaceholders(jsonFiles[key], deviceTablet, false);
      replacePlaceholders(jsonFiles[key], deviceMobile, false);

      replacePlaceholders(jsonFiles[key], globalDefault, false);
      const currentObject = jsonFiles[key];
      if (key === 'DeviceDesktop') {
        if (typeof currentObject === 'object' && currentObject !== null) {
          prefixDeviceVariables(currentObject, `desktop`);
        }
      } else if (key === 'DeviceMobile') {
        if (typeof currentObject === 'object' && currentObject !== null) {
          prefixDeviceVariables(currentObject, `mobile`);
        }
      } else if (key === 'DeviceTablet') {
        if (typeof currentObject === 'object' && currentObject !== null) {
          prefixDeviceVariables(currentObject, `tablet`);
        }
      }

      // Remove empty objects before writing to file
      Object.keys(jsonFiles[key]).forEach((section) => {
        if (
          typeof jsonFiles[key][section] === 'object' &&
          Object.keys(jsonFiles[key][section]).length === 0
        ) {
          delete jsonFiles[key][section];
        }

        // Also check nested typography objects
        if (section === 'typography' && typeof jsonFiles[key][section] === 'object') {
          // Move typography properties to root level
          if (jsonFiles[key][section].fontSize) {
            jsonFiles[key].fontSize = jsonFiles[key][section].fontSize;
          }
          if (jsonFiles[key][section].fontFamily) {
            jsonFiles[key].fontFamily = jsonFiles[key][section].fontFamily;
          }
          if (jsonFiles[key][section].fontWeight) {
            jsonFiles[key].fontWeight = jsonFiles[key][section].fontWeight;
          }

          // Preserve any remaining custom typography values under fontSize
          for (const [k, v] of Object.entries(jsonFiles[key][section])) {
            if (!['fontSize', 'fontFamily', 'fontWeight', 'typography'].includes(k)) {
              if (!jsonFiles[key].fontSize || typeof jsonFiles[key].fontSize !== 'object') {
                jsonFiles[key].fontSize = {};
              }
              jsonFiles[key].fontSize[k] = v;
            }
          }

          // Remove the typography section
          delete jsonFiles[key][section];
        }
      });
    });

    // Remove empty Location objects
    Object.keys(jsonFiles).forEach((key) => {
      // Check if it's a Location object and it's empty
      if (
        key.startsWith('Location') &&
        (Object.keys(jsonFiles[key]).length === 0 ||
          (Object.keys(jsonFiles[key]).length === 1 &&
            jsonFiles[key].hasOwnProperty('colors') &&
            Object.keys(jsonFiles[key].colors).length === 0))
      ) {
        delete jsonFiles[key];
      }
    });

    // After all processing, clean up token names
    Object.keys(jsonFiles).forEach((themeKey) => {
      const theme = jsonFiles[themeKey];

      // Process each section of the theme
      Object.keys(theme).forEach((section) => {
        if (typeof theme[section] === 'object' && theme[section] !== null) {
          // Replace the section with sanitized keys
          theme[section] = sanitizeObjectKeys(theme[section]);
        }
      });
    });

    // Check again and replace the remaining variables with CSS variables
    // Todo: replace the code above and always use CSS variables instead of final values if works fine
    // replacePlaceholders(jsonFiles, jsonFiles, true);
    Object.keys(jsonFiles).forEach((key) => {
      if (key) {
        replacePlaceholders(jsonFiles, jsonFiles, true); // the true flag will replace references with CSS variables
        // const normalizedJson = normalizeKeysDeep(jsonFiles[key]);
        // replacePlaceholders(normalizedJson, normalizedJson, true);
        // jsonFiles[key] = normalizedJson;
      }
    });

    // Move remaining colors and remove empty sections as before
    moveRemainingColorsToColorsSection(jsonFiles);
    removeEmptySections(jsonFiles);

    let fileContent = 'const themeConfig = {\n';

    /*
     * Prepare the data for theme config file
     * 4-space indent for nested object keys and ensure single space after colon
     * Replace double quotes with single quotes around string values
     * Remove the previous 2-space indent for values
     * Write to a new TypeScript file
     */
    Object.entries(jsonFiles).forEach(([key, value]) => {
      const formattedValue = JSON.stringify(value, null, 2)
        .replace(/"(\w+)":\s+/g, '  $1: ')
        .replace(/"([^"]*)"/g, "  '$1'")
        .replace(/^/gm, '');

      fileContent += `  ${key}: ${formattedValue},\n`;
    });

    fileContent += '};\n\nexport default themeConfig; \n';

    //
    const outputPath = path.join(__dirname, '../../theme-config.ts');

    await fs.promises.writeFile(outputPath, fileContent);

    console.log(
      `\r\n\x1b[32;5;1m  :white_check_mark: A Tailwind configuration file has been generated and written to\x1b[33m ${outputPath}\x1b[0m \r\n\r\n\r\n`
    );
  } catch (error) {
    console.error('\x1b[31m%s\x1b[0m', 'Error generating output file:', error);
  }
}

// Add this function to clean up general colors after all processing
function moveRemainingColorsToColorsSection(jsonFiles: any) {
  Object.keys(jsonFiles).forEach((themeKey) => {
    const theme = jsonFiles[themeKey];

    // Make sure we have a colors section
    if (!theme.colors) {
      theme.colors = {};
    }

    // Check all top-level sections for potential color values
    Object.keys(theme).forEach((section) => {
      if (section !== 'colors' && typeof theme[section] === 'object') {
        // Get all keys in this section that contain color values
        Object.entries(theme[section]).forEach(([key, value]) => {
          if (
            typeof value === 'string' &&
            (/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(value) ||
              key.includes('color') ||
              // (key.includes('border') && !key.includes('radius')))
              (key.includes('border') && !key.includes('radius') && !key.includes('border-width')))
          ) {
            // Move to colors section
            theme.colors[key] = value;
            // Remove from original section
            delete theme[section][key];
          }
        });
      }
    });
  });
}

// Add this function after moveRemainingColorsToColorsSection
function removeEmptySections(jsonFiles: any) {
  Object.keys(jsonFiles).forEach((themeKey) => {
    const theme = jsonFiles[themeKey];

    // Remove empty sections
    Object.keys(theme).forEach((section) => {
      if (
        typeof theme[section] === 'object' &&
        theme[section] !== null &&
        Object.keys(theme[section]).length === 0
      ) {
        delete theme[section];
      }
    });
  });
}

// Add a function to sanitize all keys in an object
function sanitizeObjectKeys(obj: { [key: string]: any }) {
  const result: { [key: string]: any } = {};

  Object.entries(obj).forEach(([key, value]) => {
    // Sanitize the key
    const newKey = key.replace(/%/g, '-').replace(/[()]/g, '');

    // If value is an object, recursively sanitize its keys too
    if (typeof value === 'object' && value !== null) {
      result[newKey] = sanitizeObjectKeys(value);
    } else {
      result[newKey] = value;
    }
  });

  return result;
}

/*
 *  Calling the createThemeConfig function to generate the 'theme-config.ts' file that contains all variables from nested JSON objects in 'figma-tokens/' folder
 */
createThemeConfig();
